#include "drv/framebuffer.h"
#include "arch/pmap.h"
#include "errno.h"
#include "init/task.h"
#include "kernel/compiler.h"
#include "limine.h"
#include "mem/kvmm.h"
#include "mem/memmap.h"
#include "mem/vmalloc.h"
#include "sections.h"
#include "util/printk.h"
#include <stddef.h>
#include <stdint.h>

#define CHAR_WIDTH 8
#define CHAR_HEIGHT 16

#define MIN_CHAR 0x20
#define MAX_CHAR 0x7e

typedef uint8_t glyph_id_t;

typedef unsigned char glyph_line_t;
typedef glyph_line_t glyph_t[CHAR_HEIGHT];

static const glyph_t font[MAX_CHAR - MIN_CHAR + 1];

typedef struct {
    glyph_id_t glyph;
} char_t;

typedef struct {
    char_t character;
    size_t queue_index;
} fb_char_t;

typedef struct {
    char_t character;
    size_t buffer_index;
} queue_char_t;

typedef enum {
    ESC_INIT,
    ESC_ESC,
    ESC_PARAMS,
    ESC_PARAM_IGNORE,
    ESC_CSI,
} escape_state_t;

#define MAX_PARAMS 16

typedef struct {
    printk_sink_t base;
    volatile void *framebuffer;
    fb_char_t *buffer;
    queue_char_t *queue;
    uint64_t pitch;
    size_t queue_count;
    uint32_t width;
    uint32_t height;
    uint32_t fg_color;
    uint32_t x;
    uint32_t y;
    escape_state_t state;
    escape_state_t next_state;
    unsigned params[MAX_PARAMS];
    unsigned nparam;
} fb_sink_t;

static void fb_display(fb_sink_t *self, char_t character, uint32_t x, uint32_t y) {
    size_t index = y * self->width + x;
    fb_char_t *buffer = &self->buffer[index];
    queue_char_t *queue;

    if (buffer->queue_index == 0) {
        if (!memcmp(&buffer->character, &character, sizeof(character))) return;
        buffer->queue_index = ++self->queue_count;
        queue = &self->queue[buffer->queue_index - 1];
        queue->buffer_index = index;
    } else {
        queue = &self->queue[buffer->queue_index - 1];
    }

    queue->character = character;
}

static glyph_id_t ascii_to_glyph_id(unsigned char c) {
    if (c < MIN_CHAR || c > MAX_CHAR) c = '?';
    return c - MIN_CHAR;
}

static char_t make_char(fb_sink_t *self, unsigned char c) {
    return (char_t){.glyph = ascii_to_glyph_id(c)};
}

static char_t empty_char(void) {
    return (char_t){.glyph = ascii_to_glyph_id(' ')};
}

static void maybe_scroll(fb_sink_t *self) {
    if (self->y < self->height) return;

    for (uint32_t y = 1; y < self->height; y++) {
        for (uint32_t x = 0; x < self->width; x++) {
            fb_char_t *buffer = &self->buffer[y * self->width + x];

            if (buffer->queue_index == 0) {
                fb_display(self, buffer->character, x, y - 1);
            } else {
                queue_char_t *queue = &self->queue[buffer->queue_index - 1];
                fb_display(self, queue->character, x, y - 1);
            }
        }
    }

    char_t character = empty_char();
    uint32_t y = self->height - 1;

    for (uint32_t x = 0; x < self->width; x++) {
        fb_display(self, character, x, y);
    }

    self->y -= 1;
}

static void handle_esc(fb_sink_t *self, unsigned char c);

static void handle_esc_esc(fb_sink_t *self, unsigned char c) {
    switch (c) {
    case '[':
        self->state = ESC_PARAMS;
        self->next_state = ESC_CSI;
        self->nparam = 0;
        break;
    default: self->state = ESC_INIT; break;
    }
}

static void handle_esc_params(fb_sink_t *self, unsigned char c) {
    switch (c) {
    case '0' ... '9':
        if (self->nparam < MAX_PARAMS) {
            self->params[self->nparam] *= 10;
            self->params[self->nparam] += c - '0';
        }
        break;
    case ':': break;
    case ';':
        if (self->nparam < MAX_PARAMS) self->nparam += 1;
        break;
    case '<' ... '?': break;
    case ' ' ... '/':
    case '@' ... '~':
        self->nparam += 1;
        self->state = ESC_PARAM_IGNORE;
        return handle_esc(self, c);
    default: self->state = ESC_INIT; break;
    }
}

static void handle_esc_param_ignore(fb_sink_t *self, unsigned char c) {
    switch (c) {
    case ' ' ... '/': break;
    case '@' ... '~': self->state = self->next_state; return handle_esc(self, c);
    default: self->state = ESC_INIT; break;
    }
}

static unsigned param(fb_sink_t *self, unsigned index, unsigned def) {
    if (index < self->nparam && self->params[index] != 0) return self->params[index];
    return def;
}

static void handle_csi_erase_line(fb_sink_t *self) {
    char_t c = empty_char();

    switch (param(self, 0, 0)) {
    case 0:
        for (uint32_t x = self->x; x < self->width; x++) {
            fb_display(self, c, x, self->y);
        }
        break;
    case 1:
        for (uint32_t x = 0; x < self->x; x++) {
            fb_display(self, c, x, self->y);
        }
        break;
    case 2:
        for (uint32_t x = 0; x < self->width; x++) {
            fb_display(self, c, x, self->y);
        }
        break;
    default: break;
    }
}

static void handle_esc_csi(fb_sink_t *self, unsigned char c) {
    self->state = ESC_INIT;

    switch (c) {
    case 'K': return handle_csi_erase_line(self);
    }
}

static void handle_esc(fb_sink_t *self, unsigned char c) {
    switch (self->state) {
    case ESC_ESC: return handle_esc_esc(self, c);
    case ESC_PARAMS: return handle_esc_params(self, c);
    case ESC_PARAM_IGNORE: return handle_esc_param_ignore(self, c);
    case ESC_CSI: return handle_esc_csi(self, c);
    default: UNREACHABLE();
    }
}

static void fb_write_single(fb_sink_t *self, unsigned char c) {
    switch (c) {
    case 0: self->state = ESC_INIT; break;
    case '\a': self->state = ESC_INIT; break;
    case '\b':
        self->x = self->x ? self->x - 1 : 0;
        self->state = ESC_INIT;
        break;
    case '\t':
        self->x = (self->x + 8) & ~7;
        if (self->x >= self->width) self->x = self->width - 1;
        self->state = ESC_INIT;
        return;
    case '\n':
    case '\v':
    case '\f': self->y += 1; maybe_scroll(self); // fall through
    case '\r':
        self->state = ESC_INIT;
        self->x = 0;
        return;
    case '\e': self->state = ESC_ESC; return;
    }

    if (self->state != ESC_INIT) {
        handle_esc(self, c);
        return;
    }

    fb_display(self, make_char(self, c), self->x, self->y);

    self->x += 1;

    if (self->x >= self->width) {
        self->x = 0;
        self->y += 1;
        maybe_scroll(self);
    }
}

static void fb_write(printk_sink_t *ptr, const void *data, size_t size) {
    fb_sink_t *self = (fb_sink_t *)ptr;

    while (size--) {
        fb_write_single(self, *(unsigned char *)data++);
    }
}

static void display_character(fb_sink_t *self, queue_char_t *item) {
    uint32_t x = item->buffer_index % self->width;
    uint32_t y = item->buffer_index / self->width;

    volatile void *line_ptr = self->framebuffer + y * CHAR_HEIGHT * self->pitch + x * CHAR_WIDTH * 4;
    const glyph_line_t *glyph = font[item->character.glyph];

    for (int i = 0; i < CHAR_HEIGHT; i++) {
        volatile uint32_t *px_ptr = line_ptr;
        unsigned bitmap = *glyph;

        for (int j = 0; j < CHAR_WIDTH; j++) {
            *px_ptr = (bitmap & (1u << (CHAR_WIDTH - 1))) ? self->fg_color : 0;
            px_ptr += 1;
            bitmap <<= 1;
        }

        line_ptr += self->pitch;
        glyph += 1;
    }
}

static void fb_flush(printk_sink_t *ptr) {
    fb_sink_t *self = (fb_sink_t *)ptr;

    for (size_t i = 0; i < self->queue_count; i++) {
        queue_char_t *item = &self->queue[i];
        fb_char_t *buffer = &self->buffer[item->buffer_index];

        if (memcmp(&item->character, &buffer->character, sizeof(item->character))) {
            display_character(self, item);
            buffer->character = item->character;
        }

        buffer->queue_index = 0;
    }

    self->queue_count = 0;
}

#define TEXT_COLOR_COMPONENT 0xaaaaaaaa

INIT_TEXT static uint32_t component(uint32_t mask, unsigned size, unsigned shift) {
    if (size == 0) return 0;
    if (shift >= 32) return 0;

    return (mask >> (32 - size)) << shift;
}

INIT_TEXT static int create_sink(struct limine_framebuffer *fb, uint32_t width, uint32_t height) {
    fb_sink_t *sink = vmalloc(sizeof(*sink));
    if (unlikely(!sink)) return ENOMEM;
    memset(sink, 0, sizeof(*sink));

    size_t num_chars = (size_t)width * height;

    size_t queue_offs = ((num_chars * sizeof(*sink->buffer)) + (_Alignof(queue_char_t) - 1)) &
                        ~(_Alignof(queue_char_t) - 1);
    size_t queue_size = num_chars * sizeof(*sink->queue);
    size_t total_size = queue_offs + queue_size;
    void *memory = vmalloc(total_size);
    if (unlikely(!memory)) {
        vfree(sink, sizeof(*sink));
        return ENOMEM;
    }

    uintptr_t addr;
    int error = map_mmio(
            &addr,
            (uintptr_t)fb->address - hhdm_base,
            fb->pitch * height * CHAR_HEIGHT,
            PMAP_WRITABLE | PMAP_CACHE_WC
    );
    if (unlikely(error)) {
        vfree(memory, total_size);
        vfree(sink, sizeof(*sink));
        return error;
    }

    memset(memory, 0, total_size);
    sink->buffer = memory;
    sink->queue = memory + queue_offs;

    sink->base.write = fb_write;
    sink->base.flush = fb_flush;
    sink->framebuffer = (volatile void *)addr;
    sink->pitch = fb->pitch;
    sink->width = width;
    sink->height = height;
    sink->fg_color = component(TEXT_COLOR_COMPONENT, fb->red_mask_size, fb->red_mask_shift) |
                     component(TEXT_COLOR_COMPONENT, fb->green_mask_size, fb->green_mask_shift) |
                     component(TEXT_COLOR_COMPONENT, fb->blue_mask_size, fb->blue_mask_shift);

    printk_add(&sink->base);
    printk("framebuffer: added printk sink\n");
    return 0;
}

INIT_TEXT static void fb_init(void) {
    static LIMINE_REQ struct limine_framebuffer_request fb_req = {.id = LIMINE_FRAMEBUFFER_REQUEST};
    if (!fb_req.response) return;

    for (uint64_t i = 0; i < fb_req.response->framebuffer_count; i++) {
        struct limine_framebuffer *fb = fb_req.response->framebuffers[i];
        if (fb->memory_model != LIMINE_FRAMEBUFFER_RGB || fb->bpp != 32) continue;

        uint64_t width = fb->width / CHAR_WIDTH;
        uint64_t height = fb->height / CHAR_HEIGHT;

        if (width != 0 && height != 0) {
            int error = create_sink(fb, width, height);
            if (unlikely(error)) printk("framebuffer: failed to create sink (%e)", error);
        }
    }
}

INIT_DEFINE_EARLY(framebuffer_printk, fb_init, INIT_REFERENCE(memory));

// https://github.com/viler-int10h/vga-text-mode-fonts/blob/f6a9b77d850ccf3d642331da54442d89f79ef9e3/FONTS/PC-OTHER/TOSH-SAT.F16
static const glyph_t font[MAX_CHAR - MIN_CHAR + 1] = {
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x30, 0x78, 0x78, 0x78, 0x78, 0x30, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x6c, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x6c, 0x00, 0x00},
        {0x00, 0x00, 0x18, 0x18, 0x7c, 0xc6, 0xc0, 0xc0, 0x7c, 0x06, 0x06, 0xc6, 0x7c, 0x18, 0x18, 0x00},
        {0x00, 0x00, 0x00, 0xc6, 0xc6, 0x0c, 0x0c, 0x18, 0x38, 0x30, 0x60, 0x60, 0xc6, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x38, 0x6c, 0x6c, 0x38, 0x30, 0x76, 0xde, 0xcc, 0xcc, 0xde, 0x76, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x18, 0x30, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x38, 0xfe, 0x38, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x38, 0x30, 0x60, 0x60, 0xc0, 0xc0, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xd6, 0xd6, 0xd6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x7c, 0xc6, 0x06, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0xc0, 0xfe, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x7c, 0xc6, 0x06, 0x06, 0x3c, 0x06, 0x06, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x04, 0x0c, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0xfc, 0x06, 0x06, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x3c, 0x60, 0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xfe, 0xc6, 0x06, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x06, 0x06, 0x0c, 0x78, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00},
        {0x00, 0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xde, 0xde, 0xde, 0xde, 0xc0, 0xc0, 0x7e, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xfc, 0xc6, 0xc6, 0xc6, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xf8, 0xcc, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xcc, 0xf8, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc0, 0xde, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xfc, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xc6, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xc6, 0xc6, 0xee, 0xfe, 0xd6, 0xd6, 0xd6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xc6, 0xc6, 0xe6, 0xe6, 0xf6, 0xde, 0xce, 0xce, 0xc6, 0xc6, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xf6, 0xda, 0x6c, 0x06, 0x00},
        {0x00, 0x00, 0x00, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0xd8, 0xcc, 0xcc, 0xc6, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xd6, 0xd6, 0xd6, 0xfe, 0x6c, 0x6c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xfe, 0x06, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xc0, 0xc0, 0x60, 0x60, 0x30, 0x38, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff},
        {0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x06, 0x06, 0x7e, 0xc6, 0xc6, 0xc6, 0x7e, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xdc, 0xe6, 0xc6, 0xc6, 0xc6, 0xc6, 0xe6, 0xdc, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 0x76, 0xce, 0xc6, 0xc6, 0xc6, 0xc6, 0xce, 0x76, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xfe, 0xc0, 0xc0, 0xc0, 0x7e, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xce, 0xc6, 0xc6, 0xc6, 0xce, 0x76, 0x06, 0xc6, 0x7c},
        {0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xdc, 0xe6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x1e, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0xc6, 0xc6, 0x7c},
        {0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc6, 0xcc, 0xd8, 0xf0, 0xf0, 0xd8, 0xcc, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xec, 0xfe, 0xd6, 0xd6, 0xd6, 0xd6, 0xc6, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0xe6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0xe6, 0xc6, 0xc6, 0xc6, 0xe6, 0xdc, 0xc0, 0xc0, 0xc0},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xce, 0xc6, 0xc6, 0xc6, 0xce, 0x76, 0x06, 0x06, 0x06},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0xe6, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0x70, 0x1c, 0x06, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0xfe, 0x30, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xd6, 0xd6, 0xd6, 0xd6, 0xfe, 0x6c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0xc6, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xce, 0x76, 0x06, 0xc6, 0x7c},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0xfe, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x1c, 0x30, 0x30, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x30, 0x30, 0x1c, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0xe0, 0x30, 0x30, 0x30, 0x30, 0x1c, 0x30, 0x30, 0x30, 0x30, 0xe0, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
};
